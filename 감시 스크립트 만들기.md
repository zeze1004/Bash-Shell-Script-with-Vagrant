# 감시 스크립트 만들기



## 쉘 스크립트 작성 흐름

1. 실행 후 얻을 결과를 구체적으로 나열
2. 각 과정별 명령어를 나열
3. 명령어를 순차대로 파일에 써주고 실행

## 주요 사용 명령어

- df -f
- du
- crontab
  - 스케줄러 옵션
  - -r: 스케줄러 삭제므로 주의할 것
- awk 응용



## 각 문제 별처리 스크립트

### 로그 디렉토리 용량 감시 스크립트

- 스크립트가 해야 할 일
  - 로그 디렉토리의 크기를 확인하고 지정한 용량보다 크면 관리자에게 알람을 보냄
- 처리 과정의 정리 및 명령어
  - 로그 디렉토리의 크기를 확인 (du)
  - 크기를 비교해서 처리 (if)
  - 관리자에게 알림
    - telegram
      - API가 간단한 장점
  - 스크립트 작성
  - 테스트



포트 확인

```sh
# netstat -nltpu
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      1/systemd
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      629/nginx: master p
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      606/sshd
tcp6       0      0 :::111                  :::*                    LISTEN      1/systemd
# nginx가 80 포트를 사용 중
tcp6       0      0 :::80                   :::*                    LISTEN      629/nginx: master p
tcp6       0      0 :::22                   :::*                    LISTEN      606/sshd
udp        0      0 0.0.0.0:111             0.0.0.0:*                           1/systemd
udp        0      0 127.0.0.1:323           0.0.0.0:*                           566/chronyd
udp6       0      0 :::111                  :::*                                1/systemd
udp6       0      0 ::1:323                 :::*                                566/chronyd
```

모니터 디렉토리 이동

```sh
[root@cent1 /]# find -name monitor
./vagrant/SHELL/monitor

[root@cent1 /]# cd ./vagrant/SHELL/monitor
```

디스크 사이즈 비교 sh

```sh
#!/bin/bash

# 용량 감시 스크립트
# 1. 로그 디렉토리의 크기를 확인
# 2. 크기가 1기가 이상일 경우 관리자에게 알림
# 3. 1기가 미만일 경우 아무 것도 안함

# 감시할 디렉토리가 바뀌면 DIR 변수 수정
DIR="/var/log/nginx"
# 디스크 사이즈를 SIZE에 저장
SIZE="$(du -m ${DIR} | awk '{print $1}')"
HOST="${HOSTNAME}"

# SIZE가 1024 메가바이트 보다 크면 then 작으면 else 출력
if [ ${SIZE} -ge 1024 ]
then
	TEXT="${DIR} 사용량이 1기가가 넘었습니다."
	/vagrant/SHELL/bot.sh "${HOST}" "${TEXT}"
else
        echo "1기가를 넘지 않았습니다."
fi
```

- `$()`: () 안의 스크립트는 출력되지 않는 사일런트 명령어

- 비교연산자 ([출처](https://m.blog.naver.com/dsz08082/221842241053))

  | 비교 연산자 | 의미                 | 비교 연산자 | 의미                         |
  | ----------- | -------------------- | ----------- | ---------------------------- |
  | -eq         | 같음                 | <           | 이중 소괄호에서, 더 작음     |
  | -ne         | 같지 않음            | <=          | 이중 소괄호에서, 작거나 같음 |
  | -gt         | 더 큼                | >           | 이중 소괄호에서, 더 큼       |
  | -ge         | 크거나 같음          | >=          | 이중 소괄호에서, 크거나 같음 |
  | -lt         | 더 작음              | ==, =       | 문자열 비교, 같음            |
  | -le         | 더 작거나 같음       | !=          | 문자열 비교, 같지 않음       |
  | -z          | 문자열이 null인가?   | -a          | 논리 and                     |
  | -n          | 문자열이 null이 아님 | -o          | 논리 or                      |

텔레그램 봇 만들기

[생성 및 사용 방법 참고 사이트](https://chicpro.dev/telegram%ED%85%94%EB%A0%88%EA%B7%B8%EB%9E%A8-%EB%B4%87%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%B4-%EB%A9%94%EC%84%B8%EC%A7%80-%EC%A0%84%EC%86%A1%ED%95%98%EA%B8%B0/)



텔레그램 봇 API sh

```sh
#!/bin/bash
# telegram bot으로 메세지를 보내는 쉘 스크립트
# 2개의 파라미터가 필요 "1. 서버 호스트 이름" "2. 메세지"
# 실행 결과는 현재 날짜/시각, 서버 이름, 메세지를 텔레그램으로 전송



# 파라미터 2개보다 적다면 아래 사용법 출력 후 종료
if [ $# -ne 2 ]
then
        echo
        echo "Usage "
        echo "$0 {HOSTNAME} {MESSAGES}"
        echo
        echo "example) "
        echo "$0 \"cent1\" \"/var/log/nginx 파티션을 확인하세요\""
        echo
        exit 0
fi

# 텔레그램 봇 관련 정보
ID="..."
API_TOKEN="..."
URL="https://api.telegram.org/bot${API_TOKEN}/sendMessage"

#날짜
DATE="$(date "+%Y-%m-%d %H:%M")"

# 보낼 메세지 작성
TEXT="${DATE} [$1] $2"

#메세지 보내기
curl -s -d "chat_id=${ID}&text=${TEXT}" ${URL} > /dev/null

```



### 디스크 파티션 사용량 감시 스크립트

```sh
# 5번째 필드인 Use%가 디스크 파티션 출력
[root]# df -h
Filesystem      Size  Used Avail Use% Mounted on
devtmpfs        467M     0  467M   0% /dev
tmpfs           485M     0  485M   0% /dev/shm
tmpfs           485M   13M  472M   3% /run
tmpfs           485M     0  485M   0% /sys/fs/cgroup
/dev/sda1        10G  3.6G  6.5G  36% /
tmpfs            97M     0   97M   0% /run/user/1000
```

- %를 삭제해야 숫자를 비교할 수 있음

- ```sh
  # df -h | awk '{print$5}'
  Use%
  0%
  0%
  3%
  0%
  36%
  0%
  # df -h | awk '{print$5}' | awk -F% '{print $1}'
  Use
  0
  0
  3
  0
  36
  0
  # df -h | awk '{print$5}' | awk -F% '{print $1}' | grep -v "^[A-Z]"
  0
  0
  3
  0
  36
  0
  ```

  - `awk -F% '{print $1}'`: %를 기준으로 1번필드만 출력

  - `grep -v "^[A-Z]"`: Use를 없애기 위해 사용 대문자가 없는 곳만 선택

    반대로 Use만 출력 가능

    ```sh
    # df -h | awk '{print$5}' | awk -F% '{print $1}' | grep "^[A-Z]"
    Use
    ```

- 결과적으로 숫자만 출력했으나 어느 파티션인지 구분할 수 없어서 위 코드는 무용지물...!

- [grep 옵션 정리](./명령어 모음/grep.md)

#### `awk` 내장함수 사용하기

- awk 언어로 만든 프로그램

  활용법이 어마어마하다

```sh
# df -h | awk '{gsub("%",""); print $5,$6}'
Use Mounted
0 /dev
0 /dev/shm
3 /run
0 /sys/fs/cgroup
36 /
0 /run/user/1000
```

- `gsub("이거를","요고로 치환")`

- `column -t`:보기 쉽게 탭으로 구분해서 출력

- ```sh
  # df -h | awk '{gsub("%",""); print $5,$6}' | column -t
  Use  Mounted
  0    /dev
  0    /dev/shm
  3    /run
  0    /sys/fs/cgroup
  36   /
  0    /run/user/1000
  ```

  

#### 변수 설정으로 확장성

- ```sh
  # df -h | awk '{gsub("%",""); USE=$5; MNT=$6; print USE,MNT}' | column -t
  Mounted         Mounted
  /dev            /dev
  /dev/shm        /dev/shm
  /run            /run
  /sys/fs/cgroup  /sys/fs/cgroup
  /               /
  /run/user/1000  /run/user/1000
  ```

#### awk 식 if문

```sh
# df -h | awk '{gsub("%",""); USE=$5; MNT=$6; if (USE > 10) print USE,MNT}' | column -t
Use  Mounted
36   /

## 변수 사용 안했을 시
# df -h | awk '{gsub("%",""); if ($5 > 10) print $5,$6}' | column -t
Use  Mounted
36   /
```

#### 최종

```sh
# df -h | awk '{gsub("%",""); USE=$5; MNT=$6; if (USE > 10) print MNT,"파티션이 ",USE,"%을 사용 중입니다."}' | grep -v "^[A-Z]"
/ 파티션이  36 %을 사용 중입니다.
## MNT가 루트, USE = 36
```

- grep -v를 사용해 대문자 제외 출력



#### 한 줄 스크립트 기반으로 스크립트 파일 작성

```sh
#!/bin/bash

## 역슬래시는 띄어쓰기
## awk 내부 코드끼리는 띄어써도 ㅇㅋ
TEXT="$(df -h | \
        awk '{
                gsub("%","");
                USE=$5;
                MNT=$6;
                if (USE > 10)
                        print MNT,"파티션이 ",USE,"%을 사용 중입니다."}' |\
        grep -v "^[A-Z]")"

## TEXT 안의 코드가 실행되면 TEXT 사이즈가 1BYTE 이상
if [ ${#TEXT} -gt 1 ]
then
        echo "파티션 용량 10% 넘는 디렉토리 존재"
        ## TEXT 출력
        echo ${TEXT}
else
        echo "파티션 용량 10% 넘는 디렉토리 없음"
fi
-------------------------------------------------------------------------------

# chmod 700 partition_monitor
# ./partition_monitor.sh
파티션 용량 10% 넘는 디렉토리 존재
/ 파티션이 36 %을 사용 중입니다.

```

- `변수="$()"`
- `${#변수}`: 변수 사이즈

#### 봇 알람 쉘 스크립트 파일 사용하기

```sh
#!/bin/bash

TEXT="$(df -h | \
        awk '{
                gsub("%","");
                USE=$5;
                MNT=$6;
                if (USE > 10)
                        print MNT,"파티션이 ",USE,"%을 사용 중입니다."}' |\
        grep -v "^[A-Z]")"
HOST="$(hostname)"

# TEXT 안의 코드가 실행되면 TEXT 사이즈가 1BYTE 이상
if [ ${#TEXT} -gt 1 ]
then
        /vagrant/SHELL/monitor/bot.sh "${HOST}" "${TEXT}"
        echo ${TEXT}
else
        echo "파티션 용량 10% 넘는 디렉토리 없음"
fi
```



### nginx 서버 로그 디렉토리 사용량 알람 스크립트와 파티션 알람 스크립트 출력 결과

```sh
# ./partition_monitor.sh
/ 파티션이 36 %을 사용 중입니다.

# ./log_monitor.sh
/var/log/nginx 사용량이 1기가가 넘었습니다.
```

<p align = "center"><img src="사진 폴더/telegram_bot.png"></img></p>



### 적용

- crontab에 등록
  - 1시간에 한 번

#### 크론탭이란?

- 특정 시간에 특정 작업을 지정할 수 있는 스케줄러

- ```sh
  ## 크론탭 에디터 모드로 편집
  crontab -e
  
  ## 크론탭 내용 확인
  crontab -l
  
  ## 크론탭 삭제
  crontab -r
  ```

- ```sh
  ## 사용 예시
  crontab -e
  *****ls -al ## 해당 명령어를 매 분마다 실행
  ```

  - [주기 예제(출처)](https://jdm.kr/blog/2)

  - ```sh
    *　　　　　　*　　　　　　*　　　　　　*　　　　　　*
    분(0-59)　　시간(0-23)　　일(1-31)　　월(1-12)　　　요일(0-7)
    
    ## 예제
    ## 특정 시간 실행
    ## 매주 금요일 오전 5시 45분에 test.sh 를 실행
    45 5 * * 5 /home/script/test.sh
    
    ## 반복 실행
    ## 매일 매시간 0분, 20분, 40분에 test.sh 를 실행
    0,20,40 * * * * /home/script/test.sh
    
    ## 범위 실행
    ## 매일 1시 0분부터 30분까지 매분 tesh.sh 를 실행
    0-30 1 * * * /home/script/test.sh
    
    ## 간격 실행
    ## 매 10분마다 test.sh 를 실행
    */10 * * * * /home/script/test.sh
    
    ## 심화 예제
    ## 5일에서 6일까지 2시,3시,4시에 매 10분마다 test.sh 를 실행
    */10 2,3,4 5-6 * * /home/script/test.sh
    ```



##### 크랩톤 작성

```sh
# 로그 디렉토리 감시 스크립트
# 정시마다 실행
00 * * * * /vagrant/SHELL/monitor/log_monitor >/dev/null 2>&1

# 디스크 파티션 감시 스크립트
# 30분 마다 실행
30 * * * * /vagrant/SHELL/monitor/partition_monitor.sh >/dev/null
2>&1
```

- `>/dev/null 2>&1`: 출력 내용을 리다이렉트하기, 이 때 2(에러)를 1(표준출력)에 덧붙여서 리다이렉트
  - 0: 표준 입력(stdin)
  - 1: 표준 출력(stdout)
  - 2: 에러 출력(stderr)

#### 크론탭 로그 확인

- 1분 마다 쌓이도록 수정 후 `/var/log/cron`에서 작동되는지 확인 가능

```sh
# cat /var/log/cron
...
Dec  3 01:00:01 cent1 CROND[1891]: (root) CMD (/vagrant/SHELL/monitor/partition_monitor.sh >/dev/null 2>&1)
Dec  3 01:00:01 cent1 CROND[1892]: (root) CMD (/vagrant/SHELL/monitor/log_monitor >/dev/null 2>&1)
Dec  3 01:01:01 cent1 CROND[1921]: (root) CMD (run-parts /etc/cron.hourly)
Dec  3 01:01:01 cent1 run-parts[1921]: (/etc/cron.hourly) starting 0anacron
Dec  3 01:01:02 cent1 run-parts[1921]: (/etc/cron.hourly) finished 0anacron
Dec  3 01:01:02 cent1 CROND[1942]: (root) CMD (/vagrant/SHELL/monitor/partition_monitor.sh >/dev/null 2>&1)
Dec  3 01:01:02 cent1 CROND[1943]: (root) CMD (/vagrant/SHELL/monitor/log_monitor >/dev/null 2>&1)
Dec  3 01:02:01 cent1 CROND[1979]: (root) CMD (/vagrant/SHELL/monitor/partition_monitor.sh >/dev/null 2>&1)
Dec  3 01:02:01 cent1 CROND[1980]: (root) CMD (/vagrant/SHELL/monitor/log_monitor >/dev/null 2>&1)
Dec  3 01:03:01 cent1 CROND[2015]: (root) CMD (/vagrant/SHELL/monitor/partition_monitor.sh >/dev/null 2>&1)
Dec  3 01:03:01 cent1 CROND[2017]: (root) CMD (/vagrant/SHELL/monitor/log_monitor >/dev/null 2>&1)
Dec  3 01:03:02 cent1 crontab[2032]: (root) DELETE (root)
Dec  3 01:03:07 cent1 crontab[2041]: (root) LIST (root)
```

<p align = "center"><img src="사진 폴더/telegram_bot_crontab.png"></img></p>

#### 만약 실행 결과를 로그로 남기고 싶다면?

```sh
# crontab -e
## 매분마다 실행 결과를 cron_log.sh에 저장
## >>는 덮어쓰기, >만 할 시 출력할 때마다 갱신
*/1 * * * * /vagrant/SHELL/monitor/log_monitor >> /vagrant/SHELL/monitor/cron_log.sh 2>&1

# cat cron_log.sh
1기가를 넘지 않았습니다.
1기가를 넘지 않았습니다.
...
```

