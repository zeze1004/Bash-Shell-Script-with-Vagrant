# 감시 스크립트 만들기



## 쉘 스크립트 작성 흐름

1. 실행 후 얻을 결과를 구체적으로 나열
2. 각 과정별 명령어를 나열
3. 명령어를 순차대로 파일에 써주고 실행

## 주요 사용 명령어

- df -f
- du
- crontab
  - 스케줄러 옵션
  - -r: 스케줄러 삭제므로 주의할 것
- awk 응용



## 각 문제 별처리 스크립트

### 로그 디렉토리 용량 감시 스크립트

- 스크립트가 해야 할 일
  - 로그 디렉토리의 크기를 확인하고 지정한 용량보다 크면 관리자에게 알람을 보냄
- 처리 과정의 정리 및 명령어
  - 로그 디렉토리의 크기를 확인 (du)
  - 크기를 비교해서 처리 (if)
  - 관리자에게 알림
    - telegram
      - API가 간단한 장점
  - 스크립트 작성
  - 테스트



포트 확인

```sh
# netstat -nltpu
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      1/systemd
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      629/nginx: master p
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      606/sshd
tcp6       0      0 :::111                  :::*                    LISTEN      1/systemd
# nginx가 80 포트를 사용 중
tcp6       0      0 :::80                   :::*                    LISTEN      629/nginx: master p
tcp6       0      0 :::22                   :::*                    LISTEN      606/sshd
udp        0      0 0.0.0.0:111             0.0.0.0:*                           1/systemd
udp        0      0 127.0.0.1:323           0.0.0.0:*                           566/chronyd
udp6       0      0 :::111                  :::*                                1/systemd
udp6       0      0 ::1:323                 :::*                                566/chronyd
```

모니터 디렉토리 이동

```sh
[root@cent1 /]# find -name monitor
./vagrant/SHELL/monitor

[root@cent1 /]# cd ./vagrant/SHELL/monitor
```

디스크 사이즈 비교 sh

```sh
#!/bin/bash

# 용량 감시 스크립트
# 1. 로그 디렉토리의 크기를 확인
# 2. 크기가 1기가 이상일 경우 관리자에게 알림
# 3. 1기가 미만일 경우 아무 것도 안함

# 감시할 디렉토리가 바뀌면 DIR 변수 수정
DIR="/var/log/nginx"
# 디스크 사이즈를 SIZE에 저장
SIZE="$(du -m ${DIR} | awk '{print $1}')"
HOST="${HOSTNAME}"

# SIZE가 1024 메가바이트 보다 크면 then 작으면 else 출력
if [ ${SIZE} -ge 1024 ]
then
	TEXT="${DIR} 사용량이 1기가가 넘었습니다."
	/vagrant/SHELL/bot.sh "${HOST}" "${TEXT}"
else
        echo "1기가를 넘지 않았습니다."
fi
```

- `$()`: () 안의 스크립트는 출력되지 않는 사일런트 명령어

- 비교연산자 ([출처](https://m.blog.naver.com/dsz08082/221842241053))

  | 비교 연산자 | 의미                 | 비교 연산자 | 의미                         |
  | ----------- | -------------------- | ----------- | ---------------------------- |
  | -eq         | 같음                 | <           | 이중 소괄호에서, 더 작음     |
  | -ne         | 같지 않음            | <=          | 이중 소괄호에서, 작거나 같음 |
  | -gt         | 더 큼                | >           | 이중 소괄호에서, 더 큼       |
  | -ge         | 크거나 같음          | >=          | 이중 소괄호에서, 크거나 같음 |
  | -lt         | 더 작음              | ==, =       | 문자열 비교, 같음            |
  | -le         | 더 작거나 같음       | !=          | 문자열 비교, 같지 않음       |
  | -z          | 문자열이 null인가?   | -a          | 논리 and                     |
  | -n          | 문자열이 null이 아님 | -o          | 논리 or                      |

텔레그램 봇 만들기

[생성 및 사용 방법 참고 사이트](https://chicpro.dev/telegram%ED%85%94%EB%A0%88%EA%B7%B8%EB%9E%A8-%EB%B4%87%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%B4-%EB%A9%94%EC%84%B8%EC%A7%80-%EC%A0%84%EC%86%A1%ED%95%98%EA%B8%B0/)



텔레그램 봇 API sh

```sh
#!/bin/bash
# telegram bot으로 메세지를 보내는 쉘 스크립트
# 2개의 파라미터가 필요 "1. 서버 호스트 이름" "2. 메세지"
# 실행 결과는 현재 날짜/시각, 서버 이름, 메세지를 텔레그램으로 전송



# 파라미터 2개보다 적다면 아래 사용법 출력 후 종료
if [ $# -ne 2 ]
then
        echo
        echo "Usage "
        echo "$0 {HOSTNAME} {MESSAGES}"
        echo
        echo "example) "
        echo "$0 \"cent1\" \"/var/log/nginx 파티션을 확인하세요\""
        echo
        exit 0
fi

# 텔레그램 봇 관련 정보
ID="..."
API_TOKEN="..."
URL="https://api.telegram.org/bot${API_TOKEN}/sendMessage"

#날짜
DATE="$(date "+%Y-%m-%d %H:%M")"

# 보낼 메세지 작성
TEXT="${DATE} [$1] $2"

#메세지 보내기
curl -s -d "chat_id=${ID}&text=${TEXT}" ${URL} > /dev/null

```



### 디스크 파티션 사용량 감시 스크립트

```sh
# 5번째 필드인 Use%가 디스크 파티션 출력
[root]# df -h
Filesystem      Size  Used Avail Use% Mounted on
devtmpfs        467M     0  467M   0% /dev
tmpfs           485M     0  485M   0% /dev/shm
tmpfs           485M   13M  472M   3% /run
tmpfs           485M     0  485M   0% /sys/fs/cgroup
/dev/sda1        10G  3.6G  6.5G  36% /
tmpfs            97M     0   97M   0% /run/user/1000
```

- %를 삭제해야 숫자를 비교할 수 있음

- ```sh
  # df -h | awk '{print$5}'
  Use%
  0%
  0%
  3%
  0%
  36%
  0%
  # df -h | awk '{print$5}' | awk -F% '{print $1}'
  Use
  0
  0
  3
  0
  36
  0
  # df -h | awk '{print$5}' | awk -F% '{print $1}' | grep -v "^[A-Z]"
  0
  0
  3
  0
  36
  0
  ```

  - `awk -F% '{print $1}'`: %를 기준으로 1번필드만 출력

  - `grep -v "^[A-Z]"`: Use를 없애기 위해 사용 대문자가 없는 곳만 선택

    반대로 Use만 출력 가능

    ```sh
    # df -h | awk '{print$5}' | awk -F% '{print $1}' | grep "^[A-Z]"
    Use
    ```

    ### [grep 옵션 정리](https://recipes4dev.tistory.com/157)

  - ```sh
    # grep [OPTION...] PATTERN [FILE...]
            -E        : PATTERN을 확장 정규 표현식(Extended RegEx)으로 해석.
            -F        : PATTERN을 정규 표현식(RegEx)이 아닌 일반 문자열로 해석.
            -G        : PATTERN을 기본 정규 표현식(Basic RegEx)으로 해석.
            -P        : PATTERN을 Perl 정규 표현식(Perl RegEx)으로 해석.
            -e        : 매칭을 위한 PATTERN 전달.
            -f        : 파일에 기록된 내용을 PATTERN으로 사용.
            -i        : 대/소문자 무시.
            -v        : 매칭되는 PATTERN이 존재하지 않는 라인 선택.
            -w        : 단어(word) 단위로 매칭.
            -x        : 라인(line) 단위로 매칭.
            -z        : 라인을 newline(\n)이 아닌 NULL(\0)로 구분.
            -m        : 최대 검색 결과 갯수 제한.
            -b        : 패턴이 매치된 각 라인(-o 사용 시 문자열)의 바이트 옵셋 출력.
            -n        : 검색 결과 출력 라인 앞에 라인 번호 출력.
            -H        : 검색 결과 출력 라인 앞에 파일 이름 표시.
            -h        : 검색 결과 출력 시, 파일 이름 무시.
            -o        : 매치되는 문자열만 표시.
            -q        : 검색 결과 출력하지 않음.
            -a        : 바이너리 파일을 텍스트 파일처럼 처리.
            -I        : 바이너리 파일은 검사하지 않음.
            -d        : 디렉토리 처리 방식 지정. (read, recurse, skip)
            -D        : 장치 파일 처리 방식 지정. (read, skip)
            -r        : 하위 디렉토리 탐색.
            -R        : 심볼릭 링크를 따라가며 모든 하위 디렉토리 탐색.
            -L        : PATTERN이 존재하지 않는 파일 이름만 표시.
            -l        : 패턴이 존재하는 파일 이름만 표시.
            -c        : 파일 당 패턴이 일치하는 라인의 갯수 출력.
    ```

- 결과적으로 숫자만 출력했으나 어느 파티션인지 구분할 수 없어서 위 코드는 무용지물...!

#### `awk` 내장함수 사용하기

- awk 언어로 만든 프로그램

  활용법이 어마어마하다

```sh
# df -h | awk '{gsub("%",""); print $5,$6}'
Use Mounted
0 /dev
0 /dev/shm
3 /run
0 /sys/fs/cgroup
36 /
0 /run/user/1000
```

- `gsub("이거를","요고로 치환")`

- `column -t`:보기 쉽게 탭으로 구분해서 출력

- ```sh
  # df -h | awk '{gsub("%",""); print $5,$6}' | column -t
  Use  Mounted
  0    /dev
  0    /dev/shm
  3    /run
  0    /sys/fs/cgroup
  36   /
  0    /run/user/1000
  ```

  

#### 변수 설정으로 확장성

- ```sh
  # df -h | awk '{gsub("%",""); USE=$5; MNT=$6; print USE,MNT}' | column -t
  Mounted         Mounted
  /dev            /dev
  /dev/shm        /dev/shm
  /run            /run
  /sys/fs/cgroup  /sys/fs/cgroup
  /               /
  /run/user/1000  /run/user/1000
  ```

#### awk 식 if문

```sh
# df -h | awk '{gsub("%",""); USE=$5; MNT=$6; if (USE > 10) print USE,MNT}' | column -t
Use  Mounted
36   /

## 변수 사용 안했을 시
# df -h | awk '{gsub("%",""); if ($5 > 10) print $5,$6}' | column -t
Use  Mounted
36   /
```

#### 최종

```sh
# df -h | awk '{gsub("%",""); USE=$5; MNT=$6; if (USE > 10) print MNT,"파티션이 ",USE,"%을 사용 중입니다."}' | grep -v "^[A-Z]"
/ 파티션이  36 %을 사용 중입니다.
## MNT가 루트, USE = 36
```

- grep -v를 사용해 대문자 제외 출력



#### 한 줄 스크립트 기반으로 스크립트 파일 작성

```sh
#!/bin/bash

## 역슬래시는 띄어쓰기
## awk 내부 코드끼리는 띄어써도 ㅇㅋ
TEXT="$(df -h | \
        awk '{
                gsub("%","");
                USE=$5;
                MNT=$6;
                if (USE > 10)
                        print MNT,"파티션이 ",USE,"%을 사용 중입니다."}' |\
        grep -v "^[A-Z]")"

## TEXT 안의 코드가 실행되면 TEXT 사이즈가 1BYTE 이상
if [ ${#TEXT} -gt 1 ]
then
        echo "파티션 용량 10% 넘는 디렉토리 존재"
        ## TEXT 출력
        echo ${TEXT}
else
        echo "파티션 용량 10% 넘는 디렉토리 없음"
fi
-------------------------------------------------------------------------------

# chmod 700 partition_monitor
# ./partition_monitor.sh
파티션 용량 10% 넘는 디렉토리 존재
/ 파티션이 36 %을 사용 중입니다.

```

- `변수="$()"`
- `${#변수}`: 변수 사이즈

#### 봇 알람 쉘 스크립트 파일 사용하기

```sh
#!/bin/bash

TEXT="$(df -h | \
        awk '{
                gsub("%","");
                USE=$5;
                MNT=$6;
                if (USE > 10)
                        print MNT,"파티션이 ",USE,"%을 사용 중입니다."}' |\
        grep -v "^[A-Z]")"
HOST="$(hostname)"

# TEXT 안의 코드가 실행되면 TEXT 사이즈가 1BYTE 이상
if [ ${#TEXT} -gt 1 ]
then
        /vagrant/SHELL/monitor/bot.sh "${HOST}" "${TEXT}"
        echo ${TEXT}
else
        echo "파티션 용량 10% 넘는 디렉토리 없음"
fi
```



### nginx 서버 로그 디렉토리 사용량 알람 스크립트와 파티션 알람 스크립트 출력 결과

```sh
# ./partition_monitor.sh
/ 파티션이 36 %을 사용 중입니다.

# ./log_monitor.sh
/var/log/nginx 사용량이 1기가가 넘었습니다.
```

![telegram_bot](D:\Project\Bash-Shell-Script-with-Vagrant\사진 폴더\telegram_bot.png)

